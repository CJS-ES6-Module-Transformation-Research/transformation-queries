 import {write_status as op_type} from "../src/abstract_fs_v2/interfaces";
import {ProjConstructionOpts} from "../src/abstract_fs_v2/ProjectManager";
import {CommandModule, Arguments, Argv } from 'yargs'
import  yargs from 'yargs'

import { isAbsolute, join } from "path";
import { cwd } from "process";
  interface ProgramArgs {
	source: string
	dest?: string
	suffix?: string
	copy_node_modules?: boolean
	naming?:naming
	named?: boolean
 	'default'?: boolean
	ignored?: string[]
	import_type?:naming
	  n?:boolean
}
type naming = "default" | "named"

let opts:ProjConstructionOpts = getOptionData()
// 	= {
// 	isModule: false,
// 	suffix: suffix,
// 	target_dir: output,
// 	write_status: operation,
// 	copy_node_modules: false, //TODO
// 	isNamed: naming_format === "named",
// 	ignored: ignored,
// 	report: tf_args.report
// }


 function getOptionData() {
	 type ccm =  { handler(args: Arguments<ProgramArgs>): void; aliases: string; describe: string; command: string }
	 let copyCommandModule:ccm = {
		 command: "tf-copy <source> <dest>",
		 // builder: (args: Argv<ProgramArgs>): Argv<ProgramArgs> => {
		 // 	// .option('filter',{})
		 // 	return optionized(args)
		 // 	// .option('include-node_modules', {type:"boolean"})
		 //
		 // },
		 aliases: 'c',
		 describe: "Executes a transformation from CommonJS modules to ECMAScript modules on a project, copying the result to a destination.",
		 handler(args: Arguments<ProgramArgs>): void {
			 switch (args._[0]) {
				 case 'c':
					 args._[0] = 'tf-copy'
					 break;
			 }
		 }
	 }

	 type inpm = { handler(args: Arguments<ProgramArgs>): void; aliases: string; builder: (args: Argv<ProgramArgs>) => Argv<ProgramArgs>; describe: string; command: string }
	 let inPlaceCommandModule: inpm = {
		 command: "tf-proj <source> [suffix]",
		 builder: (args: Argv<ProgramArgs>): Argv<ProgramArgs> => {
			 return args
		 },
		 aliases: 'i',
		 describe: "Executes a transformation from CommonJS modules to ECMAScript modules on a project directory in-place.",
		 handler(args: Arguments<ProgramArgs>): void {
			 switch (args._[0]) {
				 case 'i':
					 args._[0] = 'tf-proj'
					 break;
			 }
			 if (!args['suffix']) {
				 args['suffix'] = ''
			 }
		 }
	 }


	 let _cwd: string = cwd();
	 let tf_args =
		require('yargs')
		 .command(copyCommandModule)
		 .command(inPlaceCommandModule)
		 .option('import_type', {choices: ["named", "default"], nargs: 1})
		 .option('n', {nargs: 0})
		 .option('ignored', {type: "string", array: true})
		 .option('report', {type: "boolean", nargs: 0})
		 .strict()
		 .argv;
	 let input: string = tf_args.source;
	 let output = '';
	 let suffix = '';
	 let operation: op_type
	 // @ts-ignore
	 let naming_format: naming;

	 if (tf_args.import_type) {
		 naming_format = tf_args.import_type as naming
	 } else if (tf_args.n) {
		 naming_format = "named"
	 } else {
		 naming_format = "default";
	 }

	 // @ts-ignore
	 let ignored: string[] = tf_args.ignored ? tf_args.ignored : [];
	 if (tf_args._[0] === "tf-proj") {
		 operation = "in-place";
		 suffix = tf_args.suffix
	 } else if (tf_args._[0] === "tf-copy") {
		 operation = "copy";
		 output = tf_args.dest
		 if (output && !isAbsolute(output)) {
			 output = join(_cwd, output)
		 }
	 }

	 if (!isAbsolute(input)) {
		 input = join(_cwd, input)
	 }
	 ignored.forEach((elem, index, arr) => {
		 if (!isAbsolute(elem)) {
			 arr[index] = join(_cwd, elem)
		 }
	 });
	 return {
		 input,
		 target_dir: output,
		 suffix,
		 write_status: operation,
		 isNamed: naming_format === "named",
		 ignored,
		 report: tf_args.report && true
	 };
 }
// 	 function copyCommandModule(): CommandModule<ProgramArgs, ProgramArgs> {
//
//
// 		 return {
// 			 command: "tf-copy <source> <dest>",
// 			 builder: (args: Argv<ProgramArgs>): Argv<ProgramArgs> => {
// 				 // .option('filter',{})
// 				 return optionized(args)
// 				 // .option('include-node_modules', {type:"boolean"})
//
// 			 },
// 			 aliases: 'c',
// 			 describe: "Executes a transformation from CommonJS modules to ECMAScript modules on a project, copying the result to a destination.",
// 			 handler(args: Arguments<ProgramArgs>): void {
// 				 switch (args._[0]) {
// 					 case 'c':
// 						 args._[0] = 'tf-copy'
// 						 break;
// 				 }
// 			 }
// 		 }
// 	 }
// }


// function optionized(args: Argv<ProgramArgs>) {
// 	let _args
// 		= args.option({
// 		import_type: {choices: ["named", "default"], nargs: 1},
//
// 		ignored: {type: "string", array: true}
// 	});
// 	return _args
// }

// function inPlaceCommandModule(): CommandModule<ProgramArgs, ProgramArgs> {
//   	return
// }